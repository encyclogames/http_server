/*
 ============================================================================
 Name        : Project 1 : HTTP Liso Web Server
 Author      : Fahad Islam
 Description : Implementation of Project 1
 ============================================================================
 */

/* To compile: gcc  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdarg.h>
#include "lisod.h"
#include "client_pool.h"


cmd_line_args cla;


////////////////////////////  OLD OLD OLD
u_long curr_nodeID;
char *hostname;
int local_port;

void init_from_command_line(int argc, char **argv);
void web_server();
void accept_client(int sock, client_pool *p);
void handle_input(client *c, client_pool *p);
void server_loop(int sock, client_pool *p);
void disconnect_client(client *c, client_pool *p);


/*
 * Prints the command line format of the lisod program and exits immediately
 */
void usage() {
	fprintf(stderr, "usage: ./lisod <HTTP port> <HTTPS port> <log file> <lock file> "
			"<www folder> <CGI folder or script name> <private key file> <certificate file>\n");
	exit(-1);
}

/*
 * initialize the details of the web server using the information from the command line
 */
void init_from_command_line(int argc, char **argv)
{
	cla.http_port = atoi(argv[0]);
	cla.https_port= atoi(argv[1]);
	strcpy(cla.log_file, argv[2]);
	strcpy(cla.lock_file, argv[3]);
	strcpy(cla.www_folder, argv[4]);
	strcpy(cla.cgi_folder, argv[5]);
	strcpy(cla.private_key_file, argv[6]);
	strcpy(cla.certificate_file, argv[7]);
}


int main( int argc, char *argv[] )
{
	if (argc < 8) {
		usage();
	}

	init_from_command_line(argc, argv);

	printf( "Listening on port %d for new clients \n", cla.http_port);
	fflush(stdout);

	web_server();
	return 0;
}

int
init_socket(int port)
{
	int s;
	struct sockaddr_in sin;
	int on = 1;

	bzero(&sin, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
	sin.sin_addr.s_addr = INADDR_ANY;
#if defined(__FreeBSD__) || defined(__APPLE__)
	//sin.sin_len = sizeof(sin); /* BSD/MacOS Only */
#endif

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		perror("could not create socket");
		exit(-1);
	}

	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
		perror("could not setsockopt SO_REUSEADDR");
		exit(-1);
	}

	if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) == -1) {
		perror("could not bind socket");
		exit(-1);
	}

	if (listen(s, 15) == -1) {
		perror("could not listen on socket");
		exit(-1);
	}

	return s;
}

void
init_hostname() {
#define HOSTNAME_LEN 30

	if (!(hostname = (char *)malloc(HOSTNAME_LEN))) {
		perror("could not allocate");
		exit(-1);
	}

	if (gethostname(hostname, HOSTNAME_LEN) < 0) {
		perror("error getting local hostname");
		exit(-1);
	}

}

void
web_server() {

	int listen_socket;

	client_pool *p = client_pool_create();

	listen_socket = init_socket(cla.http_port);

	init_hostname();

	server_loop(listen_socket, p);  // also needs p arg for client pool
}

void
server_loop(int sock, client_pool *p)
{
	fd_set readfds;
	fd_set writefds;
	int i;
	int maxfd;
	int rc;
	signal(SIGPIPE, SIG_IGN);

	while (1)
	{
		FD_ZERO(&readfds);
		FD_ZERO(&writefds);

		FD_SET(sock, &readfds);
		maxfd = sock;

		for (i = 0; i < MAX_CLIENTS; i++)
		{
			client *c;
			c = p->clients[i];
			if (c == NULL)
				continue;

			FD_SET(c->sock, &readfds);
			if (c->sock > maxfd) maxfd = c->sock;
		}

		rc = select(maxfd+1, &readfds, NULL, NULL, NULL);
		if (FD_ISSET(sock, &readfds))
		{
			accept_client(sock, p);
		}

		for (i = 0; i < MAX_CLIENTS; i++)
		{
			client *c;
			c = p->clients[i];
			if (c == NULL)
				continue;

			if (FD_ISSET(c->sock, &readfds))
				handle_input(c, p);
		}
	}
}

/* Nit-picky note:  the gethostbyaddr function is technically a blocking
 * function.  The grading scripts will accept this;  most async
 * DNS lookup routines are a bit painful in C. */
void
set_hostname(client *c)
{
	char addrbuf[32];
	inet_ntop(AF_INET, &c->cliaddr.sin_addr, addrbuf, sizeof(addrbuf));
//	DPRINTF(DEBUG_CLIENTS, "Doing reverse lookup for client %d IP %s\n",
//			c->sock, addrbuf);

	struct hostent *he;
	if ((he = gethostbyaddr(&c->cliaddr.sin_addr, sizeof(struct sockaddr_in),
			AF_INET)) != NULL) {
		strncpy(c->hostname, he->h_name, MAX_HOSTNAME);
	} else {
		strncpy(c->hostname, addrbuf, MAX_HOSTNAME);
	}
//	DPRINTF(DEBUG_CLIENTS, "Client %d name: %s\n", c->sock, c->hostname);
}

void
accept_client(int sock, client_pool *p)
{
	int clisock;
	struct sockaddr_in cliaddr;
	//    socklen_t addrlen;
	socklen_t addrlen = sizeof(struct sockaddr_in);
	client *c;

//	DPRINTF(DEBUG_SOCKETS, "Accepting a connection\n");
	clisock = accept(sock, (struct sockaddr *)&cliaddr, &addrlen);
	if (clisock == -1) {
		perror("client accept failed");
		return;
	}
//	DPRINTF(DEBUG_SOCKETS|DEBUG_CLIENTS, "Got client on socket %d\n", clisock);

	c = new_client(p, clisock);
	c->cliaddr = cliaddr;
	set_hostname(c);
}

void
disconnect_client(client *c, client_pool *p)
{
//	DPRINTF(DEBUG_CLIENTS, "Disconnecting client %d\n", c->sock);
//	proto_disconnect(c, p, NULL);
	close(c->sock);
	delete_client(p, c->sock);
}

void
handle_input(client *c, client_pool *p)
{
	char inbuf[MAX_REQUEST_LEN+1];
	int nread;

//	DPRINTF(DEBUG_INPUT, "Handling input from client %d\n", c->sock);
	nread = read(c->sock, inbuf, sizeof(inbuf)-1);

	if (nread == 0)
	{
		disconnect_client(c, p);
		return;
	}
	if (nread == -1)
	{
		return;
	}
	////////////////////////////////////    ECHO CODE
	write( c->sock, inbuf, nread);




	////////////////////////////////////    OLD IRC HANDLING CODE, REPLACE WITH HTTP HANDLING CODE
//	inbuf[nread] = '\0';
////	DPRINTF(DEBUG_INPUT, "Got:  **%s** from client\n", inbuf);
//
//	int nleft = nread;
//	char *ibo = inbuf;
//
//	while (nleft > 0)
//	{
//		char *end;
//		int writebytes = nleft - (c->inbuf_size);
//
//		strncat(c->inbuf, ibo, writebytes);
//		c->inbuf_size += writebytes;
//
//		nleft -= writebytes;
//		ibo += writebytes;
//
//		do
//		{
//			end = strpbrk(c->inbuf, "\r\n");
//
//			if (end == NULL && c->inbuf_size >= MAX_MSG_LEN)
//			{
//				reply(c, ERR_UNKNOWNCOMMAND, " :Unknown command");
//				/* XXX - this is the wrong reply code */
//				c->inbuf_size = 0;
//				c->inbuf[0] = '\0';
//			}
//
//			if (end != NULL)
//			{
//				int end_offset;
//				*end++ = '\0';
//				handle_line(c, p, c->inbuf, routefd);
//				if (*end == '\n') end++;
//
//				end_offset = (end - c->inbuf);
//				c->inbuf_size -= end_offset;
//
//				bcopy(end, c->inbuf, c->inbuf_size);
//				c->inbuf[c->inbuf_size] = '\0';
//			}
//		} while (end > 0);
//	}
}

/***** HTTP ERROR RESPONSE MAKER*****/
/////////////////////////////////////////////////////////////////////////////
/*
 * clienterror - returns an error message to the client
 */
/* $begin clienterror */
//void clienterror(int fd, char *cause, char *errnum,
//		char *shortmsg, char *longmsg)
//{
//	char buf[MAX_REQUEST_LEN], body[MAX_REQUEST_LEN];
//
//	/* Build the HTTP response body */
//	sprintf(body, "<html><title>My Error</title>");
//	sprintf(body, "%s<body bgcolor=""ffffff"">\r\n", body);
//	sprintf(body, "%s%s: %s\r\n", body, errnum, shortmsg);
//	sprintf(body, "%s<p>%s: %s\r\n", body, longmsg, cause);
//	sprintf(body, "%s<hr><em>My Proxy</em>\r\n", body);
//
//	/* Print the HTTP response */
//	sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
//	Rio_writen(fd, buf, strlen(buf));
//	sprintf(buf, "Content-type: text/html\r\n");
//	Rio_writen(fd, buf, strlen(buf));
//	sprintf(buf, "Content-length: %d\r\n\r\n", (int)strlen(body));
//	Rio_writen(fd, buf, strlen(buf));
//	Rio_writen(fd, body, strlen(body));
//}
/* $end clienterror */




